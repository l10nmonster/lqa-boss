# LLM Development Guide: LQA Boss PWA Viewer

This document provides context and guidance for Large Language Models (LLMs) assisting with the development and maintenance of the LQA Boss PWA Viewer.

## Project Overview

The LQA Boss PWA Viewer is a Progressive Web Application designed to open, display, and allow text editing for `.lqaboss` files. These files are ZIP archives generated by the companion LQA Boss Chrome Extension. Each `.lqaboss` file contains:
1.  A `flow_metadata.json` file detailing a "flow" of captured web pages.
2.  Multiple PNG image files, one for each captured page in the flow.

The viewer allows users to navigate through the pages of a flow, view the screenshot for each page, see highlighted text segments on the screenshot, edit the text content of these segments, and export a JSON file containing only the modified text segments.

**Core Technologies:**
*   HTML5, CSS3, JavaScript (ES6+)
*   JSZip: For unzipping the `.lqaboss` file and accessing its contents.
*   Progressive Web App (PWA) features: Service Worker for basic caching, Web App Manifest for installability and file handling.

## File Structure (Key Files)

*   `index.html`: The main HTML structure of the application.
*   `viewer.css`: All styles for the application.
*   `viewer.js`: The core JavaScript logic for all application functionality.
*   `manifest.webmanifest`: The PWA manifest file defining app properties, icons, and `file_handlers`.
*   `sw.js`: The service worker for caching the app shell.
*   `libs/jszip.min.js`: The JSZip library.
*   `icons/`: Directory containing PWA icons.

## Core Data Structures

1.  **`.lqaboss` File (ZIP Archive):**
    *   `flow_metadata.json`: (See below)
    *   `page_1_uniqueId.png`, `page_2_uniqueId.png`, etc.: Screenshot images.

2.  **`flow_metadata.json` (Inside the ZIP):**
    ```json
    {
        "flowName": "Example Flow Name",
        "createdAt": "ISO_timestamp",
        "pages": [
            {
                "pageId": "unique_page_identifier_string",
                "originalUrl": "http://captured.url",
                "timestamp": "ISO_timestamp_of_capture",
                "imageFile": "page_1_uniqueId.png", // Filename of the screenshot in the ZIP
                "segments": [
                    {
                        "text": "Original captured text",
                        "x": 100, // Logical 1x coordinate
                        "y": 200, // Logical 1x coordinate
                        "width": 150, // Logical 1x dimension
                        "height": 20, // Logical 1x dimension
                        // ... any other custom metadata captured with the segment ...
                        "customMetaField": "value"
                    },
                    // ... more segments ...
                ]
            },
            // ... more pages ...
        ]
    }
    ```

3.  **`flowData` (JavaScript variable in `viewer.js`):**
    *   This variable holds the parsed content of `flow_metadata.json` after a `.lqaboss` file is loaded. It's the primary in-memory data structure the viewer operates on.

4.  **`originalSegmentTexts` (JavaScript variable in `viewer.js`):**
    *   An object used to track if a segment's text has been modified.
    *   Key: `"pageId_segmentIndex"` (e.g., `"page_abc12_0"`)
    *   Value: The original text string of that segment as loaded from the file.

5.  **Exported JSON from "Save Changes":**
    ```json
    {
        "flowName": "Example Flow Name",
        "savedAt": "ISO_timestamp",
        "pages": [ // Only includes pages that had at least one changed segment
            {
                "pageId": "unique_page_identifier_string",
                "originalUrl": "http://captured.url", // Contextual
                "imageFile": "page_1_uniqueId.png",   // Contextual
                "changedSegments": [
                    {
                        "segmentIndex": 0, // Index of the segment within its original page's segment array
                        "originalText": "Text before edit",
                        "currentText": "Text after edit",
                        // ... any other custom metadata from the original segment (excluding x,y,w,h,text) ...
                        "customMetaField": "value"
                    }
                    // ... more changed segments for this page ...
                ]
            }
            // ... more pages with changes ...
        ]
    }
    ```

## Key Functionality & Logic in `viewer.js`

1.  **File Loading (`handleFileLoad`):**
    *   Triggered by the `<input type="file">`'s `change` event or PWA `launchQueue`.
    *   Uses `FileReader` to read the `.lqaboss` file as an `ArrayBuffer`.
    *   Uses `JSZip.loadAsync()` to parse the ZIP archive.
    *   Extracts and parses `flow_metadata.json` into `flowData`.
    *   Populates `originalSegmentTexts` by iterating through `flowData`.
    *   Calls `displayCurrentPage()` to render the first page.

2.  **Page Display (`displayCurrentPage`):**
    *   Updates page navigation UI (buttons, indicator).
    *   Retrieves the correct screenshot image data (Base64) from the `zipFile` instance using the `imageFile` path from `flowData`.
    *   Sets the `src` of the `#screenshotImage` element.
    *   **Inside `screenshotImage.onload`:**
        *   Calculates `window.devicePixelRatio (dprViewing)`.
        *   Calculates `logicalWidth = naturalWidth / dprViewing` and `logicalHeight = naturalHeight / dprViewing`.
        *   Sets `screenshotImage.style.width` and `screenshotImage.style.height` to these logical dimensions. This makes the image display at its "1x equivalent" size.
        *   Calls `renderHighlightsForCurrentPage()` and `renderEditPanelForCurrentPage()`.
        *   Calls `focusSegment()` for the first segment (or a previously active one).

3.  **Highlight Rendering (`renderHighlightsForCurrentPage`):**
    *   Clears previous highlights.
    *   Gets `dprViewing`, `displayedImageCSSWidth/Height` (`offsetWidth/Height`), and `sourceImageNaturalWidth/Height`.
    *   Calculates `scaleFactorX` and `scaleFactorY` to account for any minor discrepancies between the CSS-styled image size and the ideal `naturalSize / dprViewing`. (Ideally, these factors are close to 1.0).
    *   For each segment in `flowData.pages[currentPageIndex].segments`:
        *   **Assumes `segment.x, .y, .width, .height` are already logical 1x coordinates.**
        *   Calculates `cssLeft = segment.x * scaleFactorX`, etc.
        *   Creates a `div.highlight-box` and sets its `style.left`, `top`, `width`, `height` using these CSS-ready values.
        *   Adds an `.active` class if it's the `activeSegmentIndex`.

4.  **Edit Panel Rendering (`renderEditPanelForCurrentPage`):**
    *   Clears the panel.
    *   For each segment:
        *   Creates a `div.edit-item` and a `textarea`.
        *   Populates `textarea.value` with `segment.text`.
        *   Compares `segment.text` with `originalSegmentTexts` to add `.unmodified` or `.modified` class to the `editItemDiv`.
        *   Adds an `input` event listener to the `textarea`:
            *   Updates `flowData.pages[pIndex].segments[sIndex].text` with the new value.
            *   Updates the `.modified`/`.unmodified` class on the parent `editItemDiv`.
        *   Adds a `focus` event listener to call `focusSegment()`.
        *   Adds an "Undo" button to revert the textarea and `flowData` to `originalSegmentTexts`.

5.  **Segment Focus (`focusSegment`):**
    *   Updates `activeSegmentIndex`.
    *   Manages `.active` class on highlight boxes.
    *   Manages `.active-segment-editor` class on edit items.
    *   Focuses the corresponding textarea and scrolls it into view.

6.  **Keyboard Navigation (`handleEditPanelKeyDown`):**
    *   Handles `Tab` and `Shift+Tab`.
    *   Prevents default tab behavior.
    *   Calculates next/previous segment index.
    *   If at the start/end of segments on a page:
        *   If not the first/last page of the flow, calls `navigatePage()` to change page. `displayCurrentPage` then handles focusing the first segment of the new page (or a `setTimeout` is used to focus the last segment if shift-tabbing to a previous page).
        *   If on the first/last segment of the *entire flow*, focus remains on that segment (no cycling).

7.  **Saving Changes (`handleSaveChanges`):**
    *   Iterates through `flowData`.
    *   Compares current `segment.text` with `originalSegmentTexts`.
    *   If changes are found, builds an output structure containing only pages with changed segments, and for those segments, includes `segmentIndex`, `originalText`, `currentText`, and any other metadata (excluding `x,y,w,h,text`).
    *   If no changes overall, alerts the user.
    *   Converts the output to JSON and triggers a download via `chrome.downloads.download()` (since this `viewer.js` is now part of a PWA, this `chrome.downloads` part would need to be a standard web download mechanism if running purely as a PWA outside an extension context. **However, the current prompt implies this `viewer.js` is still the one from the extension context being adapted for PWA, so `chrome.downloads` might still be accessible if the PWA is opened from the extension. If the PWA is standalone, this needs to be a standard web `<a>` tag download.**).
        *   **Clarification for LLM:** If this `viewer.js` is for a PWA hosted on GitHub Pages and NOT running within the Chrome extension's context, `chrome.downloads.download` will NOT be available. It should use a standard web download method:
            ```javascript
            // Standard web download for PWA context
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            ```

8.  **PWA File Handling (`launchQueue` consumer):**
    *   Listens for PWA launch events with files.
    *   Gets the `File` object.
    *   Simulates a file input `change` event to pass the `File` to the existing `handleFileLoad` logic.

## Important Styling Considerations (`viewer.css`)

*   **Full-width Viewer:** The `.container` is `width: 100%`.
*   **Layout:** `.content-area` uses Flexbox (or Grid) to arrange `#screenshot-section` and `#edit-panel-section`.
*   **Screenshot Sizing:**
    *   `#screenshotImage` has its `style.width` and `style.height` set by `viewer.js` to `naturalSize / dprViewing` to display at logical 1x size.
    *   `#screenshotContainer` uses `width: min-content` so it's only as wide as the styled image.
    *   `#screenshot-section` has `overflow: auto` for scrolling if the styled image is too large for the section's allocated space. It does *not* `flex-grow` but rather `flex-shrink: 0`.
*   **Edit Panel Sizing:**
    *   `#edit-panel-section` has `flex-grow: 1` to take remaining space and `min-width` to prevent it from collapsing too much.
*   **Highlight Boxes:** Absolutely positioned relative to `#screenshotContainer`. Their CSS pixel dimensions are calculated in `viewer.js` based on logical 1x segment coordinates and then adjusted by `scaleFactorX/Y`.

## Potential Future Changes / Areas of Attention

*   **Robustness of `scaleFactorX/Y`:** The calculation of `scaleFactorX/Y` in `renderHighlightsForCurrentPage` is a fallback. Ideally, `displayedImageCSSWidth` should very closely match `sourceImageNaturalWidth / dprViewing`, making these factors close to 1. If they deviate significantly, it might indicate issues with how the image's CSS dimensions are being set or interfered with.
*   **Performance with many segments/pages:** DOM manipulation for highlights and edit panel can become slow. Consider virtual scrolling or more optimized rendering if performance degrades.
*   **State Management:** For a more complex application, a more formal state management approach (beyond global variables like `flowData`) might be beneficial.
*   **Service Worker Caching Strategy:** The current `sw.js` is basic. A more advanced strategy might be needed for better offline support or handling dynamic assets (though this app is mostly static once a file is loaded).
*   **Error Handling:** Continue to improve user-facing error messages and console logging.
*   **Accessibility (a11y):** Review for ARIA attributes and keyboard navigation beyond tabbing (e.g., for page navigation buttons).
*   **Custom File Input Styling:** The default `<input type="file">` button is hidden, and a `<label>` is styled. This is standard but ensure it's accessible.

This guide should provide a good starting point for an LLM to understand the project's architecture, data flow, and key logic components when asked to make modifications.